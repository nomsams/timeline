<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
  <title>Chronos Enterprise • Precision OSINT</title>

  <script src="https://unpkg.com/@mozilla/readability/Readability.js"></script>

  <style>
    /* ==========================================================================
       1. CSS VARIABLES (STRICT DESIGN SYSTEM)
       ========================================================================== */
    :root {
      --bg: #050505; --surface: #111111; --surface-elevated: #1a1a1a;
      --border: #2a2a2a; --border-focus: #444444;
      --text: #f0f0f0; --text-muted: #888888;
      --accent: #007aff; --accent-hover: #005bb5;
      --success: #28cd41; --warning: #ffcc00; --error: #ff3b30;
      --type-person: #bf5af2; --type-event: #ff3b30; --type-general: #007aff;
      --font-ui: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      --radius: 6px; --shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
      --transition: 0.15s cubic-bezier(0.2, 0, 0, 1);
      --grid-size: 50px;
    }

    [data-theme="light"] {
      --bg: #f5f5f7; --surface: #ffffff; --surface-elevated: #e8e8ed;
      --border: #d2d2d7; --border-focus: #999999;
      --text: #1d1d1f; --text-muted: #86868b;
      --shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
    }

    /* ==========================================================================
       2. RESET & BASE
       ========================================================================== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
    body { background: var(--bg); color: var(--text); font-family: var(--font-ui); height: 100vh; display: flex; flex-direction: column; overflow: hidden; -webkit-font-smoothing: antialiased; font-variant-numeric: tabular-nums; }
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

    /* ==========================================================================
       3. LAYOUT COMPONENTS
       ========================================================================== */
    header { height: 48px; background: var(--surface); border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; flex-shrink: 0; z-index: 100; user-select: none; }
    .brand { font-size: 13px; font-weight: 700; letter-spacing: -0.2px; display: flex; align-items: center; gap: 8px; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); box-shadow: 0 0 8px var(--success); transition: background 0.3s; }
    .status-dot.working { background: var(--warning); box-shadow: 0 0 8px var(--warning); animation: pulse 1s infinite alternate; }
    @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
    
    .workspace { display: flex; flex: 1; overflow: hidden; position: relative; }
    
    /* Sidebar */
    .sidebar { width: 340px; background: var(--surface); border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 50; flex-shrink: 0; transition: transform var(--transition); }
    .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
    .sidebar-section:last-child { border-bottom: none; overflow-y: auto; flex: 1; }
    @media (max-width: 768px) {
      .sidebar { position: absolute; left: 0; top: 0; bottom: 0; transform: translateX(-100%); width: 100%; max-width: 340px; box-shadow: var(--shadow); }
      .sidebar.open { transform: translateX(0); }
    }

    /* Controls */
    label { font-size: 10px; font-weight: 600; color: var(--text-muted); margin-bottom: 6px; display: flex; justify-content: space-between; text-transform: uppercase; letter-spacing: 0.5px; }
    input, select, textarea { width: 100%; background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 8px 10px; border-radius: var(--radius); font-size: 12px; font-family: inherit; margin-bottom: 12px; transition: border var(--transition); }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); }
    textarea { resize: vertical; min-height: 80px; line-height: 1.5; }
    
    button { background: var(--surface-elevated); border: 1px solid var(--border); color: var(--text); padding: 6px 12px; border-radius: var(--radius); cursor: pointer; font-size: 11px; font-weight: 600; transition: all var(--transition); display: inline-flex; align-items: center; justify-content: center; gap: 6px; }
    button:hover:not(:disabled) { border-color: var(--border-focus); }
    button.primary { background: var(--accent); color: #fff; border: none; width: 100%; padding: 10px; font-size: 12px; margin-top: 8px; }
    button.primary:hover:not(:disabled) { background: var(--accent-hover); }
    button:disabled { opacity: 0.5; cursor: wait; }

    /* Toggles & segmented controls */
    .segmented-control { display: flex; background: var(--bg); padding: 2px; border-radius: var(--radius); border: 1px solid var(--border); }
    .segment { flex: 1; padding: 4px 8px; text-align: center; font-size: 11px; color: var(--text-muted); cursor: pointer; border-radius: 4px; user-select: none; }
    .segment.active { background: var(--surface-elevated); color: var(--text); font-weight: 600; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    
    .switch { position: relative; width: 32px; height: 18px; background: var(--border); border-radius: 18px; cursor: pointer; transition: background var(--transition); display: inline-block; vertical-align: middle; }
    .switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform var(--transition); }
    .switch.on { background: var(--accent); }
    .switch.on::after { transform: translateX(14px); }

    /* Flow Indicator */
    .flow-path { display: flex; flex-direction: column; gap: 8px; margin-top: 12px; background: var(--bg); padding: 12px; border-radius: var(--radius); border: 1px solid var(--border); }
    .flow-step { display: flex; align-items: center; gap: 8px; font-size: 10px; color: var(--text-muted); transition: color var(--transition); font-family: var(--font-mono); }
    .flow-step::before { content: ''; width: 6px; height: 6px; border-radius: 50%; background: var(--border); }
    .flow-step.active { color: var(--accent); font-weight: 600; }
    .flow-step.active::before { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
    .flow-step.done { color: var(--success); }
    .flow-step.done::before { background: var(--success); }
    .flow-step.fail { color: var(--warning); }
    .flow-step.fail::before { background: var(--warning); }

    /* ==========================================================================
       4. VIEWS (TIMELINE, TABLE, HISTOGRAM)
       ========================================================================== */
    .view { flex: 1; display: none; overflow: hidden; position: relative; }
    .view.active { display: flex; flex-direction: column; }

    /* Canvas (Timeline) */
    .viewport { flex: 1; overflow: hidden; position: relative; cursor: grab; background-color: var(--bg); background-image: radial-gradient(var(--border) 1px, transparent 1px); background-size: var(--grid-size) var(--grid-size); background-position: calc(var(--pan-x) * 1px) calc(var(--pan-y) * 1px); will-change: background-position; }
    .viewport:active { cursor: grabbing; }
    .canvas-layer { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; pointer-events: none; }
    
    .axis-line { position: absolute; background: var(--border-focus); pointer-events: none; }
    .layout-x .axis-line { height: 2px; top: 0; left: -100000px; right: -100000px; transform: translateY(-50%); }
    .layout-y .axis-line { width: 2px; left: 0; top: -100000px; bottom: -100000px; transform: translateX(-50%); }

    /* Timeline Nodes */
    .node { position: absolute; background: var(--surface); border: 1px solid var(--border); padding: 10px 14px; border-radius: var(--radius); min-width: 200px; max-width: 300px; box-shadow: var(--shadow); cursor: pointer; pointer-events: auto; user-select: none; transition: box-shadow var(--transition), border-color var(--transition); }
    .node:hover, .node.dragging { border-color: var(--text-muted); z-index: 100; box-shadow: 0 8px 32px rgba(0,0,0,0.6); }
    
    .layout-x .node { top: 0; transform: translate(-50%, -50%); }
    .layout-y .node { left: 0; transform: translate(-50%, -50%); }

    .type-Person { border-top: 2px solid var(--type-person); }
    .type-Event { border-top: 2px solid var(--type-event); }
    .type-General { border-top: 2px solid var(--type-general); }
    
    .fade-start { mask-image: linear-gradient(to right, transparent, black 15%); -webkit-mask-image: linear-gradient(to right, transparent, black 15%); }
    .fade-end { mask-image: linear-gradient(to left, transparent, black 15%); -webkit-mask-image: linear-gradient(to left, transparent, black 15%); }
    
    .is-period { transform: translate(0, -50%); }
    .layout-y .is-period { transform: translate(-50%, 0); }

    .node-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px; }
    .node-date { font-family: var(--font-mono); font-size: 9px; color: var(--accent); font-weight: 600; letter-spacing: 0.5px; }
    .node-title { font-size: 13px; font-weight: 600; line-height: 1.2; color: var(--text); }
    
    .node-detail { display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); }
    .node.expanded .node-detail { display: block; }
    .node-desc { font-size: 11px; color: var(--text-muted); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; transition: all var(--transition); }
    .node-desc.full { -webkit-line-clamp: unset; }
    .node-more { font-size: 9px; color: var(--accent); cursor: pointer; margin-top: 4px; text-transform: uppercase; font-weight: 700; }
    .node-src { font-size: 9px; margin-top: 8px; word-break: break-all; }
    .node-src a { color: var(--text-muted); text-decoration: none; }
    .node-src a:hover { color: var(--accent); }

    .drag-tooltip { position: absolute; background: var(--accent); color: #fff; font-family: var(--font-mono); font-size: 10px; padding: 4px 8px; border-radius: 4px; pointer-events: none; opacity: 0; transition: opacity var(--transition); z-index: 200; transform: translate(-50%, -200%); }
    .node.dragging .drag-tooltip { opacity: 1; }

    /* Borderless Table */
    .table-view { padding: 0; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; text-align: left; font-size: 12px; }
    th { color: var(--text-muted); padding: 12px 24px; font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; position: sticky; top: 0; background: var(--surface); z-index: 2; border-bottom: 1px solid var(--border); }
    td { padding: 12px 24px; color: var(--text); border: none; }
    tr:nth-child(even) { background: rgba(255,255,255,0.01); }
    tr:hover { background: var(--surface-elevated); }

    /* Histogram */
    .hist-view { padding: 40px; display: flex; align-items: flex-end; gap: 4px; overflow-x: auto; background: var(--bg); }
    .hist-col { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; min-width: 40px; height: 100%; group: hover; }
    .hist-bar { width: 100%; background: var(--border-focus); border-radius: 4px 4px 0 0; transition: height 0.3s ease, background 0.2s; min-height: 2px; position: relative; }
    .hist-col:hover .hist-bar { background: var(--accent); }
    .hist-label { font-size: 9px; color: var(--text-muted); margin-top: 8px; font-family: var(--font-mono); }
    .hist-tooltip { position: absolute; bottom: 100%; left: 50%; transform: translate(-50%, -8px); background: var(--surface-elevated); padding: 4px 8px; border-radius: 4px; font-size: 10px; opacity: 0; pointer-events: none; transition: opacity 0.2s; white-space: nowrap; border: 1px solid var(--border); box-shadow: var(--shadow); }
    .hist-col:hover .hist-tooltip { opacity: 1; }

    /* ==========================================================================
       5. VERBOSE LOGS (COLLAPSIBLE)
       ========================================================================== */
    .logs-drawer { position: fixed; bottom: 0; left: 340px; right: 0; height: 200px; background: var(--surface); border-top: 1px solid var(--border); z-index: 150; display: flex; flex-direction: column; transition: transform 0.25s cubic-bezier(0.2, 0, 0, 1); box-shadow: 0 -4px 20px rgba(0,0,0,0.5); }
    @media (max-width: 768px) { .logs-drawer { left: 0; } }
    .logs-drawer.collapsed { transform: translateY(168px); }
    .log-header { padding: 8px 16px; background: var(--surface-elevated); border-bottom: 1px solid var(--border); font-size: 10px; font-weight: 700; text-transform: uppercase; display: flex; justify-content: space-between; align-items: center; cursor: pointer; letter-spacing: 0.5px; }
    .log-scroll { flex: 1; overflow-y: auto; padding: 12px 16px; font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); line-height: 1.6; }
    .log-entry { margin-bottom: 2px; word-break: break-all; }
    .log-entry .time { color: var(--border-focus); margin-right: 8px; }
    .log-entry.INFO { color: var(--text); }
    .log-entry.SUCCESS { color: var(--success); }
    .log-entry.WARN { color: var(--warning); }
    .log-entry.ERROR { color: var(--error); }

  </style>
</head>
<body>

<header>
  <div class="brand">
    <div class="status-dot" id="statusDot"></div>
    CHRONOS ENTERPRISE
  </div>
  
  <div class="segmented-control" style="width: 240px;">
    <div class="segment active" onclick="chronos.switchView('timeline')">Timeline</div>
    <div class="segment" onclick="chronos.switchView('table')">Table</div>
    <div class="segment" onclick="chronos.switchView('histogram')">Plots</div>
  </div>

  <div style="display:flex; gap:12px; align-items:center;">
    <button onclick="chronos.exportData('json')">Export JSON</button>
    <button onclick="chronos.exportData('schema')">Export Schema</button>
    <div class="switch on" id="themeToggle" title="Dark/Light Mode"></div>
    <button id="mobileMenu" style="display:none; padding:4px 8px;" onclick="document.querySelector('.sidebar').classList.toggle('open')">☰</button>
  </div>
</header>

<div class="workspace">
  <aside class="sidebar">
    <div class="sidebar-section">
      <label>Target Directive</label>
      <textarea id="promptInput" placeholder="Specify extraction target. e.g. 'Timeline of the Apollo space program, including key personnel and incidents.'"></textarea>
      
      <div style="display:flex; gap:8px;">
        <div style="flex:1;">
          <label>Groq API (GSK)</label>
          <input type="password" id="apiKeyInput" placeholder="gsk_..." autocomplete="off">
        </div>
        <div style="flex:1;">
          <label>Proxy Relay Key</label>
          <input type="password" id="proxyKeyInput" placeholder="chikibriki" autocomplete="off" value="chikibriki">
        </div>
      </div>

      <div style="display:flex; gap:12px;">
        <div style="flex:2;">
          <label>Inference Model</label>
          <select id="modelSelect">
            <option value="llama-3.3-70b-versatile">Llama 3.3 70B (High Precision)</option>
            <option value="llama-3.1-8b-instant">Llama 3.1 8B (Fast)</option>
            <option value="mixtral-8x7b-32768">Mixtral 8x7B (Context)</option>
          </select>
        </div>
        <div style="flex:1;">
          <label>Routing</label>
          <div class="switch on" id="proxyToggle"></div>
        </div>
      </div>

      <button id="executeBtn" class="primary" onclick="chronos.executePipeline()">Execute Extraction Pipeline</button>
      
      <div class="flow-path" id="flowPath">
        <div class="flow-step" id="step-search">1. Search Intelligence (DDG)</div>
        <div class="flow-step" id="step-crawl">2. Payload Extraction (Crawl)</div>
        <div class="flow-step" id="step-parse">3. Semantic Parsing (LLM)</div>
        <div class="flow-step" id="step-map">4. Spatial Mapping</div>
      </div>
    </div>

    <div class="sidebar-section">
      <label>Spatial Parameters</label>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="font-size:11px; color:var(--text-muted)">Axis Orientation</span>
        <div class="segmented-control" style="width:100px;">
          <div class="segment active" id="btnAxisX" onclick="chronos.setAxis('x')">X</div>
          <div class="segment" id="btnAxisY" onclick="chronos.setAxis('y')">Y</div>
        </div>
      </div>
      
      <div style="font-size:10px; color:var(--text-muted); line-height:1.6; font-family:var(--font-mono);">
        [INTERACTION_MATRIX]<br>
        • Drag background to pan<br>
        • Wheel/Pinch to zoom<br>
        • Drag node to mutate timestamp<br>
        • Click node to expand payload
      </div>
    </div>
  </aside>

  <main id="view-timeline" class="view active viewport layout-x">
    <div class="canvas-layer" id="canvasLayer">
      <div class="axis-line" id="axisLine"></div>
      </div>
  </main>

  <main id="view-table" class="view table-view">
    <table>
      <thead><tr><th>Timestamp</th><th>Category</th><th>Designation</th><th>Summary</th></tr></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </main>

  <main id="view-histogram" class="view hist-view" id="histContainer"></main>
</div>

<div class="logs-drawer collapsed" id="logsDrawer">
  <div class="log-header" onclick="document.getElementById('logsDrawer').classList.toggle('collapsed')">
    <span>Verbose System Logs</span>
    <div style="display:flex; gap:12px; align-items:center;">
      <button onclick="chronos.copyLogs(event)" style="padding:2px 8px; font-size:9px;">COPY</button>
      <span style="font-size:8px;">▲/▼</span>
    </div>
  </div>
  <div class="log-scroll" id="logScroll"></div>
</div>

<script>
/**
 * CHRONOS ENTERPRISE ENGINE (V4.0)
 * Authored by: Silas.
 * Additions: Military-grade fault-tolerant network routing matrix, WAF bypass, graceful degradation.
 */

"use strict";

// --- 1. STRICT SCHEMAS & CONSTANTS ---
const API_GROQ = "https://api.groq.com/openai/v1/chat/completions";

const PROXIES = {
  primary: "https://onbkfqayveownervyktu.supabase.co/functions/v1/cors-proxy?url=",
  fallback_1: "https://corsproxy.io/?",
  fallback_2: "https://api.allorigins.win/raw?url="
};

const JSON_SCHEMA = {
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "id": { "type": "string" },
      "title": { "type": "string" },
      "start": { "type": "string", "description": "YYYY-MM-DD" },
      "end": { "type": "string", "description": "YYYY-MM-DD or null" },
      "type": { "type": "string", "enum": ["Person", "Event", "General"] },
      "description": { "type": "string", "description": "Concise summary" },
      "sources": { "type": "array", "items": { "type": "string" } },
      "fadeStart": { "type": "boolean" },
      "fadeEnd": { "type": "boolean" }
    },
    "required": ["id", "title", "start", "type", "description"]
  }
};

// --- 2. FAULT-TOLERANT NETWORK ROUTER ---
const Network = {
  async fetchSecure(url, useProxy, proxyKey) {
    if (!useProxy) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Direct fetch failed: ${res.status}`);
      return await res.text();
    }

    // Attempt 1: Supabase Relay with Auth
    try {
      chronos.log(`[NET] Routing via Primary Relay (Supabase)...`, "INFO");
      const res = await fetch(PROXIES.primary + encodeURIComponent(url), {
        headers: { "x-proxy-key": proxyKey || "chikibriki" }
      });
      if (res.ok) return await res.text();
      chronos.log(`[NET] Primary Relay rejected request (${res.status}). Switching nodes.`, "WARN");
    } catch(e) {
      chronos.log(`[NET] Primary Relay unreachable.`, "WARN");
    }

    // Attempt 2: Public Fallback 1 (CorsProxy)
    try {
      chronos.log(`[NET] Routing via Secondary Relay (CorsProxy)...`, "INFO");
      const res = await fetch(PROXIES.fallback_1 + encodeURIComponent(url));
      if (res.ok) return await res.text();
      chronos.log(`[NET] Secondary Relay rejected request (${res.status}).`, "WARN");
    } catch(e) {}

    // Attempt 3: Public Fallback 2 (AllOrigins)
    try {
      chronos.log(`[NET] Routing via Tertiary Relay (AllOrigins)...`, "INFO");
      const res = await fetch(PROXIES.fallback_2 + encodeURIComponent(url));
      if (res.ok) return await res.text();
    } catch(e) {}

    throw new Error("All proxy layers compromised/blocked by WAF.");
  }
};

// --- 3. STATE MACHINE ---
const State = {
  events: [],
  layout: 'x',
  pixelsPerDay: 2,
  baseTime: Date.now(),
  
  // Canvas Transform
  transform: { x: 0, y: 0, scale: 1 },
  isDraggingCanvas: false,
  dragStart: { x: 0, y: 0 },
  
  // Node Mutability
  draggingNode: null,
  renderPending: false
};

// --- 4. UTILITIES ---
const Utils = {
  escape(str) {
    if (!str) return '';
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  },
  generateId() { return 'id_' + crypto.randomUUID().split('-')[0]; },
  parseDate(dateStr) {
    const d = new Date(dateStr);
    return isNaN(d.getTime()) ? null : d.getTime();
  },
  formatDate(ms) { return new Date(ms).toISOString().split('T')[0]; },
  timeToPixels(ms) { return ((ms - State.baseTime) / 86400000) * State.pixelsPerDay; },
  pixelsToTime(px) { return State.baseTime + ((px / State.pixelsPerDay) * 86400000); },
  hashEvent(ev) { return `${ev.title.toLowerCase().trim()}_${ev.start}`; }
};

// --- 5. CORE CONTROLLER ---
const chronos = {
  
  init() {
    this.bindDOM();
    this.restoreSettings();
    this.log("Chronos V4 Engine Initialized. Multi-tier routing active.", "SUCCESS");
    if(window.innerWidth < 768) document.getElementById('mobileMenu').style.display = 'block';
    
    State.transform.x = window.innerWidth / 2;
    State.transform.y = window.innerHeight / 2;
    this.requestRender();
  },

  bindDOM() {
    document.getElementById('themeToggle').addEventListener('click', e => {
      e.target.classList.toggle('on');
      document.documentElement.setAttribute('data-theme', e.target.classList.contains('on') ? 'dark' : 'light');
    });
    document.getElementById('proxyToggle').addEventListener('click', e => e.target.classList.toggle('on'));
    
    document.getElementById('apiKeyInput').addEventListener('change', e => localStorage.setItem('chronos_key', e.target.value));
    document.getElementById('proxyKeyInput').addEventListener('change', e => localStorage.setItem('chronos_proxy_key', e.target.value));

    const vp = document.getElementById('view-timeline');
    
    vp.addEventListener('mousedown', e => {
      if (e.target.closest('.node')) return;
      State.isDraggingCanvas = true;
      State.dragStart.x = e.clientX - State.transform.x;
      State.dragStart.y = e.clientY - State.transform.y;
    });

    window.addEventListener('mousemove', e => {
      if (State.isDraggingCanvas) {
        State.transform.x = e.clientX - State.dragStart.x;
        State.transform.y = e.clientY - State.dragStart.y;
        this.requestRender();
      } else if (State.draggingNode) {
        this.handleNodeDrag(e);
      }
    });

    window.addEventListener('mouseup', () => {
      State.isDraggingCanvas = false;
      if (State.draggingNode) this.endNodeDrag();
    });

    vp.addEventListener('wheel', e => {
      e.preventDefault();
      if (e.ctrlKey || e.metaKey) {
        const zoomIntensity = 0.005;
        const delta = -e.deltaY * zoomIntensity;
        const newScale = Math.min(Math.max(0.1, State.transform.scale + delta), 10);
        
        const rect = vp.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        State.transform.x -= (mouseX - State.transform.x) * (newScale / State.transform.scale - 1);
        State.transform.y -= (mouseY - State.transform.y) * (newScale / State.transform.scale - 1);
        State.transform.scale = newScale;
      } else {
        State.transform.x -= e.deltaX;
        State.transform.y -= e.deltaY;
      }
      this.requestRender();
    }, { passive: false });
  },

  restoreSettings() {
    document.getElementById('apiKeyInput').value = localStorage.getItem('chronos_key') || '';
    const pKey = localStorage.getItem('chronos_proxy_key');
    if(pKey) document.getElementById('proxyKeyInput').value = pKey;
  },

  log(msg, level="INFO") {
    const scroll = document.getElementById('logScroll');
    const time = new Date().toISOString().split('T')[1].replace('Z','');
    scroll.insertAdjacentHTML('beforeend', `<div class="log-entry ${level}"><span class="time">${time}</span> ${Utils.escape(msg)}</div>`);
    scroll.scrollTop = scroll.scrollHeight;
  },

  copyLogs(e) {
    e.stopPropagation();
    navigator.clipboard.writeText(document.getElementById('logScroll').innerText);
    this.log("Logs exported to clipboard.", "SUCCESS");
  },

  switchView(viewName) {
    document.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
    event.target.classList.add('active');
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.getElementById(`view-${viewName}`).classList.add('active');
    
    if (viewName === 'table') this.renderTable();
    if (viewName === 'histogram') this.renderHistogram();
  },

  setAxis(axis) {
    document.getElementById('btnAxisX').classList.remove('active');
    document.getElementById('btnAxisY').classList.remove('active');
    document.getElementById(`btnAxis${axis.toUpperCase()}`).classList.add('active');
    
    State.layout = axis;
    document.getElementById('view-timeline').className = `view active viewport layout-${axis}`;
    State.transform = { x: window.innerWidth/2, y: window.innerHeight/2, scale: 1 };
    this.requestRender();
    this.renderTimeline();
  },

  requestRender() {
    if (State.renderPending) return;
    State.renderPending = true;
    requestAnimationFrame(() => this.applyTransforms());
  },

  applyTransforms() {
    const layer = document.getElementById('canvasLayer');
    layer.style.transform = `translate(${State.transform.x}px, ${State.transform.y}px) scale(${State.transform.scale})`;
    
    const vp = document.getElementById('view-timeline');
    vp.style.setProperty('--pan-x', State.transform.x);
    vp.style.setProperty('--pan-y', State.transform.y);
    vp.style.setProperty('--grid-size', `${50 * State.transform.scale}px`);
    State.renderPending = false;
  },

  startNodeDrag(e, eventId, element) {
    e.stopPropagation();
    const ev = State.events.find(x => x.id === eventId);
    if (!ev) return;
    
    State.draggingNode = {
      ev: ev,
      el: element,
      tooltip: element.querySelector('.drag-tooltip'),
      dateDisplay: element.querySelector('.node-date'),
      startMouse: State.layout === 'x' ? e.clientX : e.clientY,
      startPixel: Utils.timeToPixels(Utils.parseDate(ev.start))
    };
    element.classList.add('dragging');
  },

  handleNodeDrag(e) {
    const d = State.draggingNode;
    const currentMouse = State.layout === 'x' ? e.clientX : e.clientY;
    const deltaPx = (currentMouse - d.startMouse) / State.transform.scale;
    const newPx = d.startPixel + deltaPx;
    
    if (State.layout === 'x') d.el.style.left = `${newPx}px`;
    else d.el.style.top = `${newPx}px`;
    
    const newTime = Utils.pixelsToTime(newPx);
    const newDateStr = Utils.formatDate(newTime);
    
    d.tooltip.innerText = newDateStr;
    d.dateDisplay.innerText = newDateStr + ' (Mutating)';
    d.newDateStr = newDateStr;
  },

  endNodeDrag() {
    const d = State.draggingNode;
    if (d.newDateStr) {
      d.ev.start = d.newDateStr;
      if (d.ev.end) {
        const oldStart = Utils.parseDate(d.ev.start);
        const oldEnd = Utils.parseDate(d.ev.end);
        if(oldStart && oldEnd) {
           const duration = oldEnd - oldStart;
           const newStartMs = Utils.parseDate(d.newDateStr);
           d.ev.end = Utils.formatDate(newStartMs + duration);
        }
      }
      this.log(`Node [${d.ev.id}] temporally mutated to ${d.ev.start}`, "WARN");
      State.events.sort((a,b) => Utils.parseDate(a.start) - Utils.parseDate(b.start));
    }
    
    d.el.classList.remove('dragging');
    d.dateDisplay.innerText = d.ev.end ? `${d.ev.start} - ${d.ev.end}` : d.ev.start;
    State.draggingNode = null;
  },

  setFlow(step, status) {
    const el = document.getElementById(`step-${step}`);
    el.classList.remove('active', 'done', 'fail');
    if (status) el.classList.add(status);
  },

  async executePipeline() {
    const prompt = document.getElementById('promptInput').value.trim();
    const key = document.getElementById('apiKeyInput').value;
    const proxyKey = document.getElementById('proxyKeyInput').value;
    const useProxy = document.getElementById('proxyToggle').classList.contains('on');
    const btn = document.getElementById('executeBtn');
    const dot = document.getElementById('statusDot');

    if (!prompt || !key) return alert("Target Directive and Groq Key required.");

    btn.disabled = true;
    dot.classList.add('working');
    document.getElementById('logsDrawer').classList.remove('collapsed');
    ['search', 'crawl', 'parse', 'map'].forEach(s => this.setFlow(s, ''));
    
    let compiledContext = "";
    let targetLinks = [];

    // STEP 1: SEARCH (With Graceful Degradation)
    try {
      this.setFlow('search', 'active');
      this.log(`Executing search: "${prompt}"`, "INFO");
      
      const searchUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(prompt)}`;
      const searchHtml = await Network.fetchSecure(searchUrl, useProxy, proxyKey);
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(searchHtml, 'text/html');
      
      targetLinks = Array.from(doc.querySelectorAll('.result__a')).slice(0, 3).map(a => {
        let href = a.getAttribute('href');
        if (href.includes('uddg=')) {
          try { href = decodeURIComponent(new URL(href, 'https://duckduckgo.com').searchParams.get('uddg')); } catch(e){}
        }
        return href;
      });
      
      if(targetLinks.length > 0) {
        this.setFlow('search', 'done');
        this.log(`Search complete. Acquired ${targetLinks.length} primary targets.`, "SUCCESS");
      } else {
        throw new Error("HTML structure change or bot-check prevented link extraction.");
      }
    } catch(err) {
      this.setFlow('search', 'fail');
      this.log(`Search layer failed (${err.message}). Bypassing to LLM internal weights.`, "WARN");
    }

    // STEP 2: CRAWL
    if (targetLinks.length > 0) {
      this.setFlow('crawl', 'active');
      const parser = new DOMParser();
      for (let link of targetLinks) {
        try {
          this.log(`Crawling payload: ${link}`, "INFO");
          const crawlHtml = await Network.fetchSecure(link, useProxy, proxyKey);
          const cleanDoc = parser.parseFromString(crawlHtml, 'text/html');
          
          const reader = new Readability(cleanDoc);
          const article = reader.parse();
          
          if (article && article.textContent) {
            compiledContext += `Source: ${link}\nPayload:\n${article.textContent.substring(0, 4000)}\n\n`;
            this.log(`Extraction successful from ${link}`, "SUCCESS");
          }
        } catch(err) {
          this.log(`Extraction failed on ${link}. Skipping node.`, "WARN");
        }
      }
      this.setFlow('crawl', compiledContext ? 'done' : 'fail');
    } else {
      this.setFlow('crawl', 'fail'); // Skip crawl if search failed
    }

    // STEP 3: SEMANTIC PARSE
    try {
      this.setFlow('parse', 'active');
      this.log(`Transmitting matrix to Inference Engine...`, "INFO");
      
      const model = document.getElementById('modelSelect').value;
      const sysPrompt = `You are a precision chronological parser. Extract timeline events from the user prompt and provided context. Deduplicate ongoing events. Output MUST strictly match this JSON schema: ${JSON.stringify(JSON_SCHEMA)}. If context is missing, use your highly detailed internal knowledge to fulfill the user's directive.`;
      const userPrompt = `CONTEXT:\n${compiledContext || 'No live context available. Utilize deep internal weights.'}\n\nDIRECTIVE: ${prompt}`;

      const groqRes = await fetch(API_GROQ, {
        method: "POST",
        headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/json" },
        body: JSON.stringify({
          model: model,
          messages: [{role: "system", content: sysPrompt}, {role: "user", content: userPrompt}],
          temperature: 0.1,
          response_format: { type: "json_object" }
        })
      });

      if (!groqRes.ok) {
        const errObj = await groqRes.json();
        throw new Error(errObj.error?.message || `Groq API Error: ${groqRes.status}`);
      }
      
      const groqData = await groqRes.json();
      const rawJson = JSON.parse(groqData.choices[0].message.content);
      
      let newEvents = Array.isArray(rawJson) ? rawJson : (rawJson.items || rawJson.events || Object.values(rawJson).find(v => Array.isArray(v)) || []);
      
      this.setFlow('parse', 'done');
      this.log(`Semantic parsing complete. Identified ${newEvents.length} temporal nodes.`, "SUCCESS");

      // STEP 4: SPATIAL MAP
      this.setFlow('map', 'active');
      this.mergeData(newEvents);
      this.setFlow('map', 'done');
      
      this.log("Pipeline execution finished seamlessly.", "SUCCESS");

    } catch (err) {
      this.setFlow('parse', 'fail');
      this.log(`PIPELINE FAILURE: ${err.message}`, "ERROR");
    } finally {
      btn.disabled = false;
      dot.classList.remove('working');
    }
  },

  mergeData(newEvents) {
    let added = 0, updated = 0;
    
    newEvents.forEach(ev => {
      if (!ev.id) ev.id = Utils.generateId();
      if (!ev.start) return; 
      
      const hash = Utils.hashEvent(ev);
      const existingIdx = State.events.findIndex(e => Utils.hashEvent(e) === hash);
      
      if (existingIdx > -1) {
        State.events[existingIdx] = { ...State.events[existingIdx], ...ev };
        updated++;
      } else {
        State.events.push(ev);
        added++;
      }
    });
    
    State.events.sort((a,b) => Utils.parseDate(a.start) - Utils.parseDate(b.start));
    
    if (State.events.length > 0) {
      State.baseTime = Utils.parseDate(State.events[0].start);
    }
    
    this.log(`Merge operation: ${added} added, ${updated} updated. Total spatial matrix nodes: ${State.events.length}`, "INFO");
    this.renderTimeline();
    if(document.getElementById('view-table').classList.contains('active')) this.renderTable();
    if(document.getElementById('view-histogram').classList.contains('active')) this.renderHistogram();
  },

  // --- 8. DOM RENDERERS ---
  renderTimeline() {
    const layer = document.getElementById('canvasLayer');
    Array.from(layer.children).forEach(c => { if(c.id !== 'axisLine') layer.removeChild(c); });
    
    const fragment = document.createDocumentFragment();
    
    State.events.forEach((ev, idx) => {
      const msStart = Utils.parseDate(ev.start);
      if(!msStart) return;
      
      const posPx = Utils.timeToPixels(msStart);
      const el = document.createElement('div');
      
      let classes = ['node', `type-${ev.type || 'General'}`];
      if (ev.fadeStart) classes.push('fade-start');
      if (ev.fadeEnd) classes.push('fade-end');
      if (ev.end) classes.push('is-period');
      el.className = classes.join(' ');
      
      if (State.layout === 'x') {
        el.style.left = `${posPx}px`;
        const stagger = (idx % 3) * 120;
        el.style.top = `${stagger - 120}px`; 
        
        if (ev.end) {
           const msEnd = Utils.parseDate(ev.end);
           if(msEnd) {
             const widthPx = Utils.timeToPixels(msEnd) - posPx;
             el.style.width = `${Math.max(widthPx, 200)}px`;
           }
        }
      } else {
        el.style.top = `${posPx}px`;
        const stagger = (idx % 2) * 260;
        el.style.left = `${stagger + 150}px`;
        
        if (ev.end) {
           const msEnd = Utils.parseDate(ev.end);
           if(msEnd) {
             const heightPx = Utils.timeToPixels(msEnd) - posPx;
             el.style.height = `${Math.max(heightPx, 100)}px`;
             el.style.minWidth = "200px";
           }
        }
      }

      const dateStr = ev.end ? `${ev.start} - ${ev.end}` : ev.start;
      const srcHtml = (ev.sources || []).map(s => `<div class="node-src"><a href="${s}" target="_blank">${s}</a></div>`).join('');
      
      el.innerHTML = `
        <div class="drag-tooltip"></div>
        <div class="node-header">
          <div class="node-date">${dateStr}</div>
        </div>
        <div class="node-title">${Utils.escape(ev.title)}</div>
        <div class="node-detail">
          <div class="node-desc" id="desc_${ev.id}">${Utils.escape(ev.description)}</div>
          <div class="node-more" onclick="chronos.toggleExpand(event, this, 'desc_${ev.id}')">READ FULL</div>
          ${srcHtml}
        </div>
      `;

      el.addEventListener('mousedown', e => this.startNodeDrag(e, ev.id, el));
      el.addEventListener('click', e => {
        if (!State.draggingNode) el.classList.toggle('expanded');
      });

      fragment.appendChild(el);
    });

    layer.appendChild(fragment);
  },

  toggleExpand(e, btn, descId) {
    e.stopPropagation();
    const desc = document.getElementById(descId);
    desc.classList.toggle('full');
    btn.innerText = desc.classList.contains('full') ? 'COLLAPSE' : 'READ FULL';
  },

  renderTable() {
    const tbody = document.getElementById('tableBody');
    const html = State.events.map(ev => {
      const dStr = ev.end ? `${ev.start} &rarr; ${ev.end}` : ev.start;
      return `<tr>
        <td style="font-family:var(--font-mono); color:var(--accent); font-weight:600;">${dStr}</td>
        <td><span style="font-size:10px; text-transform:uppercase; padding:2px 6px; background:var(--surface-elevated); border:1px solid var(--border); border-radius:4px; color:var(--type-${(ev.type||'general').toLowerCase()})">${ev.type}</span></td>
        <td style="font-weight:600">${Utils.escape(ev.title)}</td>
        <td style="color:var(--text-muted); font-size:11px;">${Utils.escape(ev.description)}</td>
      </tr>`;
    }).join('');
    tbody.innerHTML = html;
  },

  renderHistogram() {
    const wrap = document.getElementById('histContainer');
    if (!State.events.length) { wrap.innerHTML = ''; return; }

    const counts = {};
    State.events.forEach(ev => {
      if(!ev.start) return;
      const year = ev.start.substring(0,4);
      counts[year] = (counts[year] || 0) + 1;
    });

    const max = Math.max(...Object.values(counts));
    const sortedYears = Object.keys(counts).sort();
    
    let html = '';
    sortedYears.forEach(year => {
      const pct = (counts[year] / max) * 100;
      html += `
        <div class="hist-col">
          <div class="hist-bar" style="height:${Math.max(pct, 5)}%">
             <div class="hist-tooltip">Year: ${year}<br>Nodes: ${counts[year]}</div>
          </div>
          <div class="hist-label">${year}</div>
        </div>
      `;
    });
    wrap.innerHTML = html;
  },

  exportData(type) {
    const payload = type === 'json' ? State.events : JSON_SCHEMA;
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type: 'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `chronos_sys_${type}_${Date.now()}.json`;
    a.click();
    this.log(`Data payload [${type}] exported to filesystem.`, "SUCCESS");
  }
};

window.addEventListener('DOMContentLoaded', () => chronos.init());
</script>
</body>
</html>
